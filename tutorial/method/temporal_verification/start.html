<!DOCTYPE html>
<html lang="en" dir="ltr" class="no-js">
<head>
    <meta charset="utf-8" />
    <title>tutorial:method:temporal_verification:start - Workcraft</title>
    <script>(function(H){H.className=H.className.replace(/\bno-js\b/,'js')})(document.documentElement)</script>
    <meta name="generator" content="DokuWiki"/>
<meta name="theme-color" content="#008800"/>
<meta name="robots" content="index,follow"/>
<meta name="keywords" content="tutorial,method,temporal_verification,start"/>
<link rel="search" type="application/opensearchdescription+xml" href="../../lib/exe/opensearch.html" title="Workcraft"/>
<link rel="start" href="start.html"/>
<link rel="contents" href="start.html" title="Sitemap"/>
<link rel="manifest" href="../../lib/exe/manifest.html"/>
<link rel="alternate" type="application/rss+xml" title="Changes" />
<link rel="alternate" type="application/rss+xml" title="Current namespace" />
<link rel="edit" title="Edit this page" href="start.html"/>
<link rel="alternate" type="text/html" title="Plain HTML" href="../../_export/xhtml/tutorial/method/temporal_verification/start.xhtml"/>
<link rel="alternate" type="text/plain" title="Wiki Markup" href="../../_export/raw/tutorial/method/temporal_verification/start.raw"/>
<link rel="canonical" href="https://workcraft.org/tutorial/method/temporal_verification/start"/>
<link rel="stylesheet" href="../../lib/exe/css.php.t.dokuwiki-light-export.css"/>
<!--[if gte IE 9]><!-->
<script >/*<![CDATA[*/var NS='tutorial:method:temporal_verification';var SIG=" --- \/\/[[support@workcraft.org| ]] 2020\/11\/24 09:02\/\/";var JSINFO = {"fastwiki":{"secedit":1,"preview":1,"fastpages":1,"save":0,"fastshow":0,"fastshow_same_ns":1,"fastshow_include":"","fastshow_exclude":"","preload":false,"preload_head":"====47hsjwycv782nwncv8b920m8bv72jmdm3929bno3b3====","preload_batchsize":false,"preload_per_page":false,"locktime":840,"usedraft":1,"text_btn_show":"Show page","templatename":"dokuwiki-light-export"},"plugin_folded":{"hide":"hide","reveal":"reveal"},"move_renameokay":true,"id":"tutorial:method:temporal_verification:start","namespace":"tutorial:method:temporal_verification","ACT":"show","useHeadingNavigation":0,"useHeadingContent":0};
/*!]]>*/</script>
<script charset="utf-8" src="../../lib/exe/jquery.php.t.dokuwiki-light-export.js" defer="defer"></script>
<script charset="utf-8" src="../../lib/exe/js.php.t.dokuwiki-light-export.js" defer="defer"></script>
<!--<![endif]-->
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="shortcut icon" href="../../favicon.ico" />
<link rel="apple-touch-icon" href="../../apple-touch-icon.png" />
    </head>

<body>
    <div id="dokuwiki__site"><div id="dokuwiki__top" class="site dokuwiki mode_show tpl_dokuwiki-light-export loggedIn    ">

        
<!-- ********** HEADER ********** -->
<div id="dokuwiki__header"><div class="pad group">

    
    <div class="headings group">
        <h1><a href="../../start.html"  accesskey="" title=""><img src="../../logo.png" width="381" height="64" alt="" /></a></h1>
            </div>

    <div class="tools group">
        <!-- USER TOOLS -->
<!--
                    <div id="dokuwiki__usertools">
                <h3 class="a11y">User Tools</h3>
                <ul>
                    <li class="action profile"><a href="start.html" title="Profile" rel="nofollow"><span>Profile</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M2 3h20c1.05 0 2 .95 2 2v14c0 1.05-.95 2-2 2H2c-1.05 0-2-.95-2-2V5c0-1.05.95-2 2-2m12 3v1h8V6h-8m0 2v1h8V8h-8m0 2v1h7v-1h-7m-6 3.91C6 13.91 2 15 2 17v1h12v-1c0-2-4-3.09-6-3.09M8 6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3z"/></svg></a></li><li class="action admin"><a href="start.html" title="Admin" rel="nofollow"><span>Admin</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 15.5A3.5 3.5 0 0 1 8.5 12 3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97 0-.33-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1 0 .33.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66z"/></svg></a></li><li class="action logout"><a href="start.html" title="Log Out" rel="nofollow"><span>Log Out</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M17 17.25V14h-7v-4h7V6.75L22.25 12 17 17.25M13 2a2 2 0 0 1 2 2v4h-2V4H4v16h9v-4h2v4a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9z"/></svg></a></li>                </ul>
            </div>
        -->
        <!-- SITE TOOLS -->
<!--
        <div id="dokuwiki__sitetools">
            <h3 class="a11y">Site Tools</h3>
            <form action="../../start.html" method="get" role="search" class="search doku_form" id="dw__search" accept-charset="utf-8"><input type="hidden" name="do" value="search" /><input type="hidden" name="id" value="tutorial:method:temporal_verification:start" /><div class="no"><input name="q" type="text" class="edit" title="[F]" accesskey="f" placeholder="Search" autocomplete="on" id="qsearch__in" value="" /><button value="1" type="submit" title="Search">Search</button><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>            <div class="mobileTools">
                <form action="../..//doku.html.doku.php.html" method="get" accept-charset="utf-8"><div class="no"><input type="hidden" name="id" value="tutorial:method:temporal_verification:start" /><input type="hidden" name="sectok" value="76e97b919f59bf5330d969a72ba5bf17" /><select name="do" class="edit quickselect" title="Tools"><option value="">Tools</option><optgroup label="Page Tools"><option value="edit">Edit this page</option><option value="revisions">Old revisions</option><option value="export_pdf">Export to PDF</option><option value="menuitemfolded">Fold/unfold all</option><option value="menuitem">Rename Page</option><option value="siteexport_addpage">Export Page to HTML/PDF</option><option value="backlink">Backlinks</option></optgroup><optgroup label="Site Tools"><option value="recent">Changes</option><option value="media">Media</option><option value="index">Sitemap</option></optgroup><optgroup label="User Tools"><option value="profile">Profile</option><option value="admin">Admin</option><option value="logout">Log Out</option></optgroup></select><button type="submit">&gt;</button></div></form>            </div>
            <ul>
                <li class="action recent"><a href="start.html" title="Changes [r]" rel="nofollow" accesskey="r">Changes</a></li><li class="action media"><a href="start.html" title="Media" rel="nofollow">Media</a></li><li class="action index"><a href="start.html" title="Sitemap [x]" rel="nofollow" accesskey="x">Sitemap</a></li>            </ul>
        </div>
-->
    </div>

    <!-- BREADCRUMBS -->
<!--
    -->


    <hr class="a11y" />
</div></div><!-- /header -->

        <div class="wrapper group">

            
            <!-- ********** CONTENT ********** -->
            <div id="dokuwiki__content"><div class="pad group">
                
                <div class="pageId"><span>tutorial:method:temporal_verification:start</span></div>

                <div class="page group">
                                                            <!-- wikipage start -->
                    <div class="plugin_fastwiki_marker" style="display:none"></div><!-- TOC START -->
<div id="dw__toc" class="dw__toc">
<h3 class="toggle">Table of Contents</h3>
<div>

<ul class="toc">
<li class="level1"><div class="li"><a href="#temporal_properties">Temporal properties</a></div></li>
<li class="level1"><div class="li"><a href="#temporal_properties_vs_invariants">Temporal properties vs. invariants</a></div></li>
<li class="level1"><div class="li"><a href="#violation_traces_for_temporal_properties">Violation traces for temporal properties</a></div></li>
<li class="level1"><div class="li"><a href="#synchronous_vs_asynchronous_verification">Synchronous vs. asynchronous verification</a></div></li>
<li class="level1"><div class="li"><a href="#stutter-invariant_properties">Stutter-invariant properties</a></div></li>
<li class="level1"><div class="li"><a href="#tips_for_writing_si_properties">Tips for writing SI properties</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#try_to_avoid_sere_and_next">Try to avoid SERE and ‘next’</a></div></li>
<li class="level2"><div class="li"><a href="#prefer_overlapped_suffix-implication_and_overlapped_followed_by_to_their_non-overlapped_variants">Prefer overlapped suffix-implication and overlapped ‘followed by’ to their non-overlapped variants</a></div></li>
<li class="level2"><div class="li"><a href="#operator_ij_in_sva">Operator ##[i:j] in SVA</a></div></li>
<li class="level2"><div class="li"><a href="#edge_detection">Edge detection</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#fairness">Fairness</a></div>
<ul class="toc">
<li class="level2"><div class="li"><a href="#weak_fairness">Weak fairness</a></div></li>
<li class="level2"><div class="li"><a href="#strong_fairness">Strong fairness</a></div></li>
</ul>
</li>
<li class="level1"><div class="li"><a href="#syntactic_vs_semantic_aborts">Syntactic vs. Semantic aborts</a></div></li>
<li class="level1"><div class="li"><a href="#temporal_modalities_referring_to_the_past">Temporal modalities referring to the past</a></div></li>
<li class="level1"><div class="li"><a href="#solutions">Solutions</a></div></li>
<li class="level1"><div class="li"><a href="#references">References</a></div></li>
</ul>
</div>
</div>
<!-- TOC END -->

<h1 id="verification_of_temporal_properties_of_asynchronous_systems">Verification of temporal properties of asynchronous systems</h1>
<div class="level1">

<p>
This tutorial assumes the general familiarity with temporal properties verification and asynchronous design – ideally, you should have completed some of the <a href="../../start.html" class="wikilink1" title="tutorial:start" data-wiki-id="tutorial:start">synthesis and verification tutorials</a> for asynchronous circuits.
</p>

</div>

<h2 id="temporal_properties">Temporal properties</h2>
<div class="level2">

<p>
Temporal properties are used to reason about the behaviour of a system over time. An execution of a system can be represented as an infinite sequence of states, s<sub>0</sub>, s<sub>1</sub>, s<sub>2</sub>, …, and a temporal property is evaluated over this sequence. Typically a global system state has some structure – it comprises a finite number of Boolean entities, e.g. the state of a digital circuit comprises the values of its signals. Properties are normally formulated at the level of a module, and the property refers only to a small number of these entities, called <em>atomic propositions.</em>
</p>

<p>
The property itself would usually be an extension of Boolean formulae with <a href="https://en.wikipedia.org/wiki/Temporal_logic#Temporal_operators" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Temporal_logic#Temporal_operators">temporal modalities (a.k.a. temporal operators)</a>, e.g. some condition is required to hold either <em>always</em> (i.e. in every state s<sub>i</sub>), or <em>eventually</em> (i.e. in some state s<sub>i</sub>), or <em>until</em> some other condition starts to hold. Note that there are two versions of <em>until</em> operator: <em>strong_until</em> expects its right hand side condition to become true eventually, i.e. it does not hold otherwise, even if its left hand side is always true; in contrast, <em>weak_until</em> can be satisfied if its right hand side is always false – in which case the left hand side should always hold. Note that temporal modalities can be nested, e.g. “always, eventually <code>COND</code>” expresses that condition <code>COND</code> will keep occurring and so will be true infinitely many times, and “eventually, always <code>COND</code>” expresses that condition <code>COND</code> will stabilise and hold from some point onwards. For example, the temporal property
</p>
<div class="wrap_code plugin_wrap">
<p>
always, if <code><span style='color:red; '>req</span></code> then <code><span style='color:red; '>req</span></code> strong_until <code><span style='color:red; '>req</span></code> &amp; <code><span style='color:blue; '>ack</span></code>
</p>
</div>
<p>
states that whenever signal <code><span style='color:red; '>req</span></code> is 1, it will stay 1 until both <code><span style='color:red; '>req</span></code> and <code><span style='color:blue; '>ack</span></code> are 1, which must eventually happen due to the semantics of the <em>strong_until</em> modality.
</p>

<p>
Suppose a temporal property depends on Boolean atomic propositions a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub> (e.g. these can be the signals mentioned in the property – for the above property the atomic propositions are <code><span style='color:red; '>req</span></code> and <code><span style='color:blue; '>ack</span></code>). Then the property can ‘observe’ only partial information about each state, viz. only the values of these atomic propositions, and one can abstract away all the other information from the states in the execution, in effect, replacing a sequence of states by a sequence of values of these atomic propositions – such a sequence still contains enough information to evaluate the property.
</p>

<p>
As each atomic proposition can be either “true” or “false”, there are 2<sup>n</sup> different assignments to them. For example, if the property mentions signals <code><span style='color:red; '>req</span></code> and <code><span style='color:blue; '>ack</span></code>, but no other signals, there are 2<sup>2</sup>=4 possible assignments:
</p>
<div class="wrap_code plugin_wrap">
<p>
<code><span style='color:red; '>req</span></code>=0    <code><span style='color:red; '>req</span></code>=0    <code><span style='color:red; '>req</span></code>=1    <code><span style='color:red; '>req</span></code>=1<br/>

<code><span style='color:blue; '>ack</span></code>=0    <code><span style='color:blue; '>ack</span></code>=1    <code><span style='color:blue; '>ack</span></code>=0    <code><span style='color:blue; '>ack</span></code>=1
</p>
</div>
<p>
One can think of the set of these assignments as an abstract finite <em>alphabet,</em> and an infinite string over this alphabet would represent an abstract execution of the system (with the irrelevant state information abstracted away).
</p>

</div>

<h2 id="temporal_properties_vs_invariants">Temporal properties vs. invariants</h2>
<div class="level2">

<p>
An <em>invariant</em> is a property that can be expressed as “always <code>COND</code>”, where <code>COND</code> is some Boolean formula over atomic propositions, i.e. contains no temporal modalities. Invariants are important in practice, and are much easier to specify and verify than general temporal properties. Workcraft offers special support for them, including the verification framework based on <a href="../../../help/reach.html" class="wikilink1" title="help:reach" data-wiki-id="help:reach">REACH language</a>.
</p>

<p>
Workcraft offers several different kinds of verification:
</p>
<ul>
<li class="level1"><div class="li"> Standard properties which are applicable to many models or even many model types, e.g. deadlock-freeness of STGs or Circuits. Most of the standard properties are invariants.</div>
</li>
<li class="level1"><div class="li"> Custom invariants for a particular model, captured using <a href="../../../help/reach.html" class="wikilink1" title="help:reach" data-wiki-id="help:reach">REACH language</a>, e.g. that PMOS and NMOS transistors must never be ON simultaneously to prevent a short-circuit in a buck, see <a href="../../design/basic_buck/start.html#formal_verification" class="wikilink1" title="tutorial:design:basic_buck:start" data-wiki-id="tutorial:design:basic_buck:start">Design of basic buck controller</a>.</div>
</li>
<li class="level1"><div class="li"> Properties related to refinement – such properties have to be formulated for two models (often of a different kind), e.g. that a circuit model conforms to its environment that is an <abbr title="Signal Transition Graph">STG</abbr> model. (This is implemented by converting the models to the same kind (e.g. <abbr title="Signal Transition Graph">STG</abbr>), composing them, and verifying a complicated invariant of the composition.)</div>
</li>
<li class="level1"><div class="li"> Properties formulated on multiple models, e.g. N-way conformation of several STGs. (This is implemented by composing the models and verifying a complicated invariant of the resulting composition.)</div>
</li>
</ul>

<p>
Verification of temporal properties conceptually falls into the second category: While temporal properties is a major extension compared to REACH, there is some overlap in functionality, and so one has to understand the trade-offs when choosing which specification language is better suited to express a particular property. The considerations are as follows:
</p>
<ul>
<li class="level1"><div class="li"> REACH allows one to capture only invariants, i.e. one looks for a reachable state satisfying a certain ‘badness’ condition (e.g. a short-circuit), and the invariant one would like to prove is that no reachable state is ‘bad’ (i.e. the negation of the ‘badness’ condition is satisfied for every reachable state). Hence, if the property you are trying to express is not an invariant, i.e. you have to reason about sequences of states rather than individual states, then you have to use temporal verification.</div>
</li>
<li class="level1 node"><div class="li"> If the property you are trying to prove is an invariant then REACH should be preferred:</div>
<ul>
<li class="level2"><div class="li"> it is more flexible for expressing this kind of properties (e.g. it allows one to refer to places and transitions of the <abbr title="Signal Transition Graph">STG</abbr>, whereas temporal properties can only refer to signals);</div>
</li>
<li class="level2"><div class="li"> the verification is more efficient – not only the checking algorithm is more efficient for invariants, but also several invariants can be verified on the same unfolding prefix;</div>
</li>
<li class="level2"><div class="li"> the violation traces are finite and so much easier to debug.</div>
</li>
</ul>
</li>
</ul>

</div>

<h2 id="violation_traces_for_temporal_properties">Violation traces for temporal properties</h2>
<div class="level2">

<p>
Whenever a property is violated, a witness of the violation, in the form of a violation trace exhibiting the behaviour violating the property, is automatically computed and presented to the user to assist with debugging.
</p>

<p>
Temporal properties can be classified into:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Safety</strong> properties: Intuitively, such properties state that ‘bad things’ never happen, and a violation of a safety property can be witnessed by a <em class="u">finite</em> trace demonstrating a ‘bad thing’ happening. Note that invariants are a proper subset of safety properties – the violation trace then leads to a ‘bad’ reachable state where the invariant is not satisfied. Safety properties which are not invariants are possible but rare in practice.</div>
</li>
<li class="level1"><div class="li"> <strong>Liveness</strong> properties: Intuitively, such properties state that ‘good things’ (e.g. progress) eventually happen, and a violation of a liveness property can be witnessed only by an <em class="u">infinite</em> trace. E.g. the violation of the property “eventually <code>COND</code>” can only be witnessed by an infinite execution where condition <code>COND</code> is false in every state visited by this execution.</div>
</li>
<li class="level1"><div class="li"> Hybrid properties combining safety and liveness: While such properties are possible, it is almost always a good idea to disentangle the safety and liveness aspects into separate properties. </div>
</li>
</ul>

<p>
For the sake of uniformity, we assume that violation traces are always infinite: For safety properties, any infinite extension of a finite violation trace is still a violation trace, and vice versa, any infinite violation trace has a finite prefix (that already shows the violation) such that any extension of that prefix to an infinite trace would yield a violation trace.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap" style="width: 80%;">
<p>
In systems with deadlocks, not every finite trace can be extended to an infinite one. While it is possible to extend the semantics of temporal properties to finite traces, it is not trivial, and for simplicity Workcraft just assumes that the system is deadlock-free – this should be formally verified prior to temporal verification.
</p>

<p>
Many tools have a limitation that the main mode of verification is “verification by simulation” (i.e. basically testing), and so they have to support finite traces as all simulated traces are necessarily finite. This approach has major limitations, in particular, it is impossible to catch a violation of any liveness property. In contrast, Workcraft focuses on formal verification and supports infinite traces and liveness properties.
</p>
</div>
<p>
In this tutorial we focus on finite state systems and the often used class of temporal properties corresponding to <a href="https://en.wikipedia.org/wiki/omega-regular_language" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/omega-regular_language">omega-regular languages</a> – these are exactly the ones which can be recognised by <a href="https://en.wikipedia.org/wiki/Büchi_automaton" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Büchi_automaton">Büchi automata</a>; they correspond to the cores of <a href="https://en.wikipedia.org/wiki/Property_Specification_Language" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Property_Specification_Language">Property Specification Language (PSL)</a> and <a href="https://en.wikipedia.org/wiki/SystemVerilog#Assertions" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/SystemVerilog#Assertions">SystemVerilog Assertions (SVA)</a> and strictly include <a href="https://en.wikipedia.org/wiki/Linear_temporal_logic" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Linear_temporal_logic">Linear Temporal Logic (LTL)</a>. In this case, it turns out that if a property is violated, there must exist an infinite violation trace having a specific, lasso-shaped form, i.e. it is comprised of a finite prefix followed by a finite loop that is repeated infinitely many times. In contrast to general infinite traces, lasso-shaped traces have a finite representation, and temporal verification algorithms always search for lasso-shaped violation traces (and it is guaranteed that if a lasso-shaped violation trace does not exist then other violation traces do not exist either, i.e. the temporal property holds).
</p>

<p>
As an example, consider the following <abbr title="Signal Transition Graph">STG</abbr> specifying the mutex protocol:
<img src="mutex.stg.svg" width="182" height="115" class="svgscaleinsert mediacenter" alt="Mutex STG">
Furthermore, suppose the property one would like to verify is
</p>
<div class="wrap_code plugin_wrap">
<p>
always, if <code><span style='color:red; '>r1</span></code> then <code><span style='color:red; '>r1</span></code> strong_until <code><span style='color:red; '>r1</span></code> &amp; <code><span style='color:blue; '>g1</span></code>
</p>
</div>
<p>
Without fairness assumptions (see below), this property is violated, and the violation can be shown by the following lasso-shaped infinite trace:
<img src="lasso-shaped-trace.svg" width="232" height="86" class="svgscaleinsert mediacenter" alt="Lasso-shaped violation trace">
Intuitively, <code><span style='color:red; '>r1+</span></code> has fired, but <code><span style='color:blue; '>g1+</span></code> is indefinitely pre-empted in favour of <code><span style='color:blue; '>g2+</span></code>.
</p>

</div>

<h2 id="synchronous_vs_asynchronous_verification">Synchronous vs. asynchronous verification</h2>
<div class="level2">

<p>
Synchronous systems have one or more clock signals, and ‘interesting’ events, with few exceptions, happen at the rising or falling edges of these clock signals. In contrast, asynchronous systems do not have clocks (and so no rising or falling edges) – but there is still the notion of global discrete time that progresses (or ‘ticks’) whenever any event happens in the global system. Workcraft focuses mostly on asynchronous systems, so the latter semantics is used, which has several implications for specifying temporal properties.
</p>

<p>
The ‘global system’ is usually unknown at the time a particular module is being designed and the verification properties are being specified for it. Moreover, the ‘global system’ is subject to change due to changes in other modules, even if the way they interact with the module being designed stays the same. Furthermore, the ‘global system’ is a matter of viewpoint – it may always be considered a component of some encompassing system, all the way up to the whole Universe (and beyond, depending on your worldview). This means that temporal properties for the module being designed should tolerate any number of <em>spurious</em> ticks of the global time, i.e. ticks which are due to events invisible to the module being designed should not affect whether the property holds or not. Note that the property should tolerate not only added spurious ticks, but also removed ones: Indeed, if the value of the property changes when some spurious ticks are removed, then it would change back when these ticks are added back, i.e. it does not tolerate added spurious ticks either.
</p>

<p>
This ability to tolerate added or removed spurious ticks can be formalised in the notion of <em>stutter-invariance</em>, and is explained below.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap" style="width: 80%;">
<p>
Sensible properties of <em class="u">asynchronous</em> systems <strong>must be stutter-invariant</strong>; in other words, it can be strongly argued that if a property of an asynchronous system is not stutter-invariant then it is not sensible, and an error should be reported to the user.
</p>
</div>
<p>
For example, consider the synchronous property
</p>
<div class="wrap_code plugin_wrap">
<p>
always, if <code><span style='color:red; '>req</span></code> at the current positive clock edge then <code><span style='color:blue; '>ack</span></code> at the next positive clock edge
</p>
</div>
<p>
A naïve way of reformulating it in the asynchronous context would be, 
</p>
<div class="wrap_center wrap_round wrap_alert plugin_wrap"><div class="wrap_code plugin_wrap">
<p>
always, if <code><span style='color:red; '>req</span></code> at the current tick of global time then <code><span style='color:blue; '>ack</span></code> at the next tick
</p>
</div></div>
<p>
This property is clearly not stutter-invariant – if the property is satisfied for the module being designed, it may fail because a spurious tick may be added in the global system due to an invisible event in some far-away module that happened immediately after <code><span style='color:red; '>req</span></code> had become true. Hence, an error should be reported if the user attempts to input this property. Otherwise, the property would hold for the module in isolation, but will fail at the system level – making it very difficult to understand and debug.
</p>
<div class="wrap_center wrap_round wrap_tip plugin_wrap" style="width: 80%;">
<p>
Safety properties which hold for a module in isolation but may fail for the overall system would indicate a serious problem in the verification setup! E.g. suppose you have verified some important safety property of your system, and then your system is used as a module in a bigger system (and one can always claim that any physical system is a module within the Universe). If the property is no longer guaranteed to hold, such verification is not very useful.
</p>
</div>
<p>
A formulation that tolerates spurious ticks could be
</p>
<div class="wrap_center wrap_round wrap_alert plugin_wrap"><div class="wrap_code plugin_wrap">
<p>
always, if <code><span style='color:red; '>req</span></code> then eventually <code><span style='color:blue; '>ack</span></code>
</p>
</div></div>
<p>
However, this formulation is likely not capturing the engineer&#039;s intent correctly – note that it allows a request to withdraw before it is acknowledged, and any number of requests to be acknowledged by a single acknowledgement. The handshake protocol forbids the request to withdraw until it is acknowledged, and so a better formulation is
</p>
<div class="wrap_code plugin_wrap">
<p>
always, if <code><span style='color:red; '>req</span></code> then <code><span style='color:red; '>req</span></code> strong_until <code><span style='color:red; '>req</span></code> &amp; <code><span style='color:blue; '>ack</span></code>
</p>
</div><div class="wrap_center wrap_round wrap_tip plugin_wrap" style="width: 80%;">
<p>
Note that even though the original synchronous property was a safety property, these asynchronous re-formulations are liveness properties. This happened because in the asynchronous context one has to drop the rigid deadline for the arrival of <code><span style='color:red; '>req</span></code> imposed by the clock signal, and, due to the nature of the interleaving semantics, one has to cope with an arbitrary number of unrelated concurrent events that the overall system can execute before <code><span style='color:red; '>req</span></code> arrives. In other words, in the synchronous context, there is often (though not always) an implicit assumption that the clock signal is fair (i.e. its value will keep changing) – in the asynchronous context, the fairness is just made explicit.
</p>
</div>
<p>
Another issue stems from the interleaving semantics that is commonly used to represent concurrency in asynchronous systems. Suppose <code>x</code> is initially false, and we have a process without deadlocks that eventually sets <code>x</code> to true, and the property we would like to check is that indeed eventually <code>x</code> becomes true. Clearly, this property holds for this process in isolation. However, suppose the overall system includes also another process that does not interact with the former process and never changes <code>x</code>, just keeps executing some events.
</p>

<p>
If the system were synchronous, the property would still hold, as the clock period is selected so as to guarantee that every enabled event fires before the next clock tick. However, in an asynchronous system with the interleaving semantics for concurrent events, it is quite possible to execute events only from the latter process, perpetually ignoring the former process, i.e. an infinite trace containing events only from the latter process is a valid execution in the interleaving semantics, and the property is violated for this trace.
</p>
<div class="wrap_center wrap_round wrap_tip plugin_wrap" style="width: 80%;">
<p>
The whole purpose in life of formal verification is to find <em class="u">unlikely</em> violation traces (likely ones can be found by cheaper techniques like simulation). So this unlikely violation must be found by a good tool!
</p>
</div>
<p>
In such a situation the designer may think this trace is a false alarm, as in “reality” it is impossible to perpetually prevent the former process from executing its events, or, in other words, the scheduling of concurrent events can often be assumed to be <em class="u">fair</em>. However, this assumption is not made automatically by the tool, as it is invalid in some practical cases – some actions may happen but are not guaranteed to happen (e.g. arrival of an input, or a user&#039;s action), and so it would be reasonable to allow indefinite pre-emption for such actions. Hence, the tool must be explicitly told about the fair scheduling assumption as a part of property specification, as explained in the fairness section below.
</p>

</div>

<h2 id="stutter-invariant_properties">Stutter-invariant properties</h2>
<div class="level2">

<p>
As explained above, after abstracting away the part of the state information that is invisible to the property, an execution of the system can be abstractly represented as an infinite string over the finite alphabet corresponding to the possible assignments to atomic propositions mentioned in the property. If the system makes a step that is not visible to the property, as it does not affect the values of its atomic propositions, the string will contain a consecutive repetition of the same letter, called <em>stutter</em>. That is, spurious ticks of global time are manifested as a stutter.
</p>

<p>
Two strings are <em>stutter-equivalent</em> iff they differ only by adding / removing some <em class="u">finite</em> stutter. Let
<code>a<sup>ω</sup></code> be an infinite string obtained by infinite repetition of <code>a</code>, and <code>∼</code> be the stutter-equivalence. Then, e.g.:
</p>
<div class="wrap_code plugin_wrap">
<p>
aabbbcccd<sup>ω</sup> ∼ aaaabbccd<sup>ω</sup> ∼ abcd<sup>ω</sup>
</p>
</div>
<p>
A property is <em>stutter-invariant</em> (SI) if for any pair of stutter-equivalent strings, the property holds on one of them if and only if it holds on the other. In other words, an SI property cannot distinguish between stutter-equivalent strings, i.e. it is oblivious to stutter (and so to spurious ticks of global time).
</p>

<p>
As famously argued by Lamport <a href="#refnotes:1:note1" name="refnotes:1:ref1" class="refnotes-ref note-popup">[1]</a>, and also explained above, sensible properties of asynchronous systems must be SI. Properties which are not SI are called <em>stutter-sensitive</em> – such properties may be suitable in synchronous context but are fragile in the asynchronous context as their evaluation is affected by “spurious” ticks due to invisible events in the global system and they may not survive composition, refinement, or even minor re-design (like inserting internal signals to resolve CSC conflicts in far-away modules).
</p>

<p>
For a given temporal property, it is possible to determine automatically whether it is SI or not. This is done by constructing an automaton and performing computationally expensive automata operations. In particular, for stutter-sensitive properties, it is possible to issue diagnostics in the form of two infinite lasso-shaped traces which are stutter-equivalent, but the property holds for one of them and is violated for the other. Unfortunately, this process completely destroys the syntactic structure of the property, making it difficult to identify an offending sub-formula.
</p>

<p>
An alternative approach is to identify a suitable syntactic fragment containing only SI properties. This would either:
</p>
<ul>
<li class="level1"><div class="li"> make it impossible to specify a stutter-sensitive property; or</div>
</li>
<li class="level1"><div class="li"> would provide some syntactic-level diagnostics about sub-formulas which may cause the violation of SI.</div>
</li>
</ul>

<p>
The former approach is possible for some simple logics, e.g. for <a href="https://en.wikipedia.org/wiki/Linear_temporal_logic" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Linear_temporal_logic">Linear Temporal Logic</a> (LTL) banning the ‘next’ operator results in an SI fragment. Unfortunately, for more complicated logics like <a href="https://en.wikipedia.org/wiki/Property_Specification_Language" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/Property_Specification_Language">Property Specification Language (PSL)</a> or <a href="https://en.wikipedia.org/wiki/SystemVerilog#Assertions" class="interwiki iw_wp" title="https://en.wikipedia.org/wiki/SystemVerilog#Assertions">SystemVerilog Assertions (SVA)</a> banning the ‘next’ operator is insufficient, and other restrictions (on the context in which operators can be used, rather than a complete ban) have to be imposed.
Properties in such a syntactic fragment are called <em>syntactically stutter-invariant</em> (SSI). To summarise:
</p>
<ul>
<li class="level1"><div class="li"> every SSI property is guaranteed to be SI;</div>
</li>
<li class="level1"><div class="li"> there are properties, even sensible ones, which are SI but not SSI;</div>
</li>
<li class="level1"><div class="li"> SSI violation can be diagnosed efficiently, with useful syntactic diagnostics that may help to find the problematic sub-formula.</div>
</li>
</ul>

<p>
Note that one can get the best of both worlds using the following approach:
</p>
<ul>
<li class="level1"><div class="li"> perform the (efficient) SSI check;</div>
</li>
<li class="level1"><div class="li"> if the property is not SSI then perform the (slower) SI check;</div>
</li>
<li class="level1"><div class="li"> if the property is SSI or SI then proceed with verification;</div>
</li>
<li class="level1"><div class="li"> else output an error and the two kinds of diagnostics: A pair of traces (from the failed SI check) and syntactic-level diagnostics (from the failed SSI check) that may help the user to quickly identify the offending sub-formula.</div>
</li>
</ul>

</div>

<h2 id="tips_for_writing_si_properties">Tips for writing SI properties</h2>
<div class="level2">

<p>
This section suggests a few rules of thumb for writing SSI properties. 
</p>

</div>

<h3 id="try_to_avoid_sere_and_next">Try to avoid SERE and ‘next’</h3>
<div class="level3">

<p>
When specifying properties of asynchronous systems, <em>Sequential-Extended Regular Expressions</em> (SERE) operators used at the Sequence layer of PSL and SVA are likely to be difficult to use correctly and in an SI manner, and temporal modalities are much more natural. Moreover, the temporal modality ‘next’ stating that its operand must hold starting at the next tick of the global time often leads to the violation of SI. Avoiding SERE and ‘next’ is enough to guarantee that the property is SI.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap" style="width: 80%;">
<p>
PSL and SVA allow to specify ranges for ‘always’ and ‘eventually’ modalities – the ranged versions of these operators are defined via ‘next’ and so may result in violation of SI too, unless the range is universal. Hence avoid the ranged versions of these operators.
</p>
</div>
<p>
However, there are practical cases where SERE and ‘next’ come useful, in particular for edge detection (see below). If properly used, a property using SERE and ‘next’ may still be SI.
</p>

</div>

<h3 id="prefer_overlapped_suffix-implication_and_overlapped_followed_by_to_their_non-overlapped_variants">Prefer overlapped suffix-implication and overlapped ‘followed by’ to their non-overlapped variants</h3>
<div class="level3">

<p>
In PSL and SVA, <code>A |-&gt; B</code> is SI whenever <code>A</code> is Boolean or SI and <code>B</code> is SI, whereas <code>A |=&gt; B</code> may still be non-SI even if these conditions hold. Hence using the ‘overlapped’ variants of these operators is more likely to yield an SI property. Note that ‘overlapping’ is also more natural in the asynchronous context, e.g. the request and acknowledgement must overlap in the handshake protocol.
</p>

</div>

<h3 id="operator_ij_in_sva">Operator ##[i:j] in SVA</h3>
<div class="level3">

<p>
Apart from degraded cases, there are only a few ranges <code>[i:j]</code> which would result in an SI formula:
</p>
<ul>
<li class="level1"><div class="li"> 0:0, 0:1, 0:$ – it is then enough for both operands to be SI;</div>
</li>
<li class="level1"><div class="li"> 1:1, 1:$ – in addition to both operands being SI, further conditions are required;</div>
</li>
<li class="level1"><div class="li"> 2:$ – in addition to both operands being SI, further conditions are required which are unlikely to hold for practical properties.</div>
</li>
</ul>

<p>
Hence only former three ranges are well behaved, and you can occasionally get away with 1:1 and 1:$ in certain contexts (e.g. <code>##1</code> is somewhat similar to the ‘next’ temporal modality and can be used for edge detection, see below); all the other ranges are likely to yield a non-SI property.
</p>

</div>

<h3 id="edge_detection">Edge detection</h3>
<div class="level3">

<p>
In practice one often has to reason not only about <em>statuses</em> (e.g. values of signals) but also about <em>events,</em> i.e. signal edges. For example, properties like, “condition <code>COND</code> must hold whenever signal <code>X</code> switches from 0 to 1”, are common. The natural<sup><a href="#fn__1" id="fnt__1" class="fn_top">1)</a></sup> way of detecting an edge is to use the ‘next’ temporal modality, and following <a href="#refnotes:1:note2" name="refnotes:1:ref2" class="refnotes-ref note-popup">[2]</a> we define for any formula <code>A</code>:
</p>
<div class="wrap_code plugin_wrap">
<p>
↑<code>A</code> := !<code>A</code> &amp; next <code>A</code> <em><span style='color:gray; '>   – rising edge of A</span></em><br/>

↓<code>A</code> := <code>A</code> &amp; next !<code>A</code> <em><span style='color:gray; '>   – falling edge of A</span></em><br/>

</p>
</div>
<p>
Unfortunately, using ‘next’ removes the guarantee of the property being SI, so one must be careful to ensure that the overall property is SI. <a href="#refnotes:1:note2" name="refnotes:1:ref3" class="refnotes-ref note-popup">[2]</a> presents many useful SI patterns for edges, and more patterns can be found <a href="http://www.cs.toronto.edu/~chechik/patterns/index.html" class="urlextern" title="http://www.cs.toronto.edu/~chechik/patterns/index.html" rel="ugc nofollow">here</a>. Below are several examples:
</p>
<div class="wrap_code plugin_wrap">
<p>
eventually, ↑<code>A</code> &amp; <code>B</code> &amp; next <code>C</code><br/>

always, if ↑<code>A</code> then (<code>B</code> | next <code>C</code>)<br/>

(!↑<code>A</code> | <code>B</code> | next <code>C</code>) strong_until (↑<code>D</code> &amp; <code>E</code> &amp; next <code>F</code>)<br/>

(!↑<code>A</code> | <code>B</code> | next <code>C</code>)  weak_until  (↑<code>D</code> &amp; <code>E</code> &amp; next <code>F</code>)<br/>

</p>
</div>
<p>
Here <code>A</code>, <code>B</code>,…, <code>F</code> are arbitrary SI formulae (not just Booleans!), and these patterns still work if the rising edge is replaced with the falling edge. Note that many simplified sub-paterns can be obtained by substituting constants for <code>A</code>, <code>B</code>,…, <code>F</code>, e.g.
</p>
<div class="wrap_code plugin_wrap">
<p>
eventually, ↑<code>A</code> &amp; <code>B</code><br/>

eventually, ↑<code>A</code> &amp; next <code>B</code><br/>

always, if ↑<code>A</code> then <code>B</code><br/>

always, if ↑<code>A</code> then next <code>B</code><br/>

</p>
</div>
<p>
and many others. Furthermore, these patterns can be combined with each other and with any SI formulae using the Boolean operators and temporal modalities except ‘next’, while still guaranteeing that the resulting property is SI.
</p>

</div>

<h2 id="fairness">Fairness</h2>
<div class="level2">

<p>
It is often the case for asynchronous systems that liveness properties require some fairness assumptions to hold. There are two kinds of fairness assumptions:
</p>
<ul>
<li class="level1"><div class="li"> <strong>Weak fairness</strong> is related to fair scheduling of concurrent events, and states that if an event is enabled then it must eventually either fire or be disabled.</div>
</li>
<li class="level1"><div class="li"> <strong>Strong fairness</strong> is related to choices in the system, and states that if some option in a choice is enabled infinitely many times then it must be selected infinitely many times.</div>
</li>
</ul>

<p>
Fairness assumptions rule out some <em class="u">infinite</em> traces as impossible (note that all finite traces are still possible under any fairness assumptions discussed below, so fairness assumptions are irrelevant for safety properties whose violations can be demonstrated on finite traces).
</p>

<p>
Fairness assumptions should not be made lightly: There are situations when they are unwarranted, and by making a fairness assumption (as a part of the property) the designer takes responsibility that it indeed holds – this requires a good understanding of the module and, sometimes, its environment.
</p>

</div>

<h3 id="weak_fairness">Weak fairness</h3>
<div class="level3">

<p>
Consider a module specified by the following <abbr title="Signal Transition Graph">STG</abbr>, and the temporal property
</p>
<div class="wrap_code plugin_wrap">
<p>
always, if <code><span style='color:red; '>req</span></code> then <code><span style='color:red; '>req</span></code> strong_until <code><span style='color:red; '>req</span></code> &amp; <code><span style='color:blue; '>ack</span></code>
</p>
</div>
<p>
<img src="hs.svg" width="189" height="42" class="svgscaleinsert mediacenter" alt="Handshake STG">
Clearly, it is a liveness property that holds for this module in isolation. However, if the module is considered as a part of a bigger system that can execute other events (for simplicity, we assume that those events do not interact with the module in any way), the situation changes, as the following <abbr title="Signal Transition Graph">STG</abbr> illustrates:
<img src="hs-time-thief.svg" width="354" height="42" class="svgscaleinsert mediacenter" alt="Handshake STG with extra activity">
This <abbr title="Signal Transition Graph">STG</abbr> has an extra transition <code>time_thief</code> modelling events external to the modue which do not interact with the module in any way, but, due to the peculiarity of interleaving semantics and the possibility of unfair scheduling, can steal all the system&#039;s time! This, in particular, means that the property becomes violated due to the possible trace <code><span style='color:red; '>req+</span> time_thief<sup>ω</sup></code> that indefinitely pre-empts enabled transition <code><span style='color:blue; '>ack+</span></code> (recall that the purpose in life of formal verification is to find such unlikely traces).
</p>

<p>
In this particular case, it is likely that this trace cannot occur in reality (of course, this depends on the kind of system being modelled, and some justification is necessary – e.g. in case of circuits, <code><span style='color:blue; '>ack</span></code> is a signal computed by a logic gate, and logic gates and most latches, including MUTEX, have finite delays), and so the designer may want to declare this trace impossible in reality, and check the property only on other traces. This can be done by passing some extra knowledge about the fair scheduling of <em class="u">some</em> events (in this case, <code><span style='color:blue; '>ack+</span></code>) as an assumption encoded as a part of the property. 
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap" style="width: 80%;">
<p>
Note that assuming fair scheduling of <em class="u">all</em> events is usually a bad idea, e.g., in this case assuming fair scheduling for <code><span style='color:red; '>req+</span></code> would amount to a very bold statement about any possible environment the module can be deployed in (note that <code><span style='color:red; '>req+</span></code> is an input, i.e. produced by the environment; <code><span style='color:blue; '>ack</span></code> is an output computed by the module, so it is much better known); if <code><span style='color:red; '>req+</span></code> is produced in response to a user&#039;s action, or the module is intended for re-use, it is probably a bad idea: The trace <code>time_thief<sup>ω</sup></code> may well be possible in some cases.
</p>

<p>
For asynchronous circuits and STGs, it is usually possible to assume weak fairness for transitions of internal signals and outputs: Logic gates and most latches cannot have infinite delays, and so they will eventually either fire or be disabled. Note that this is still true for the rising transitions of a MUTEX&#039;s grants – even though their delays are unbounded due to potential metastability, they are finite, and so eventually MUTEX will resolve metastability and one of the outputs will fire and the other will become disabled. In contrast, assuming weak fairness of an input transition requires good knowledge of the environment, and so one has to make such an assumption only on the case-by-case basis, and very carefully. Furthermore, one cannot automatically assume weak fairness for the output(s) of <a href="../../../help/a2a/start.html" class="wikilink1" title="a2a:start" data-wiki-id="a2a:start">WAIT and other Asynchronous Arbitration Primitives</a>, as these outputs are controlled by inputs from the external environment (e.g. the analogue part of the circuit); hence, one has to understand the environment very well to make such an assumption.
</p>
</div>
<p>
The assumption that a certain transition <code>T</code> is scheduled fairly is common, and there is a standard ‘incantation’ for expressing it as a temporal property defined as
</p>
<div class="wrap_code plugin_wrap">
<p>
weakly_fair(<code>T</code>) := always, eventually <code>T</code> is not enabled
</p>
</div>
<p>
Note that:
</p>
<ul>
<li class="level1"><div class="li"> It is assumed that <code>T</code> cannot fire and immediately re-enable itself (otherwise a more complicated formula is needed, which would somehow track whether <code>T</code> has fired).</div>
</li>
<li class="level1"><div class="li"> The formula refers to the enabledness of a transition – it may be difficult to express this in some cases, e.g. if atomic propositions correspond to the values of signals. In circuits, one can use the function computed by the gate or latch, and in STGs one can create additional atomic propositions to represent whether a place holds a token, or even directly the enabledness status of a transition.</div>
</li>
</ul>

<p>
Now, one can use the formula “weakly_fair(<code>T</code>)” as an assumption under which another property is checked, i.e. by putting this assumption on the left hand side of an implication, and the property on its right hand side. For example, the property discussed above, can be reformulated as
</p>
<div class="wrap_code plugin_wrap">
<p>
if weakly_fair(<code><span style='color:blue; '>ack+</span></code>) then<br/>

  always, if <code><span style='color:red; '>req</span></code> then <code><span style='color:red; '>req</span></code> strong_until <code><span style='color:red; '>req</span></code> &amp; <code><span style='color:blue; '>ack</span></code>
</p>
</div>
</div>

<h4 id="exercises">Exercises</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> A fire alarm contains a fire sensor that generates an event when it detects fire (which in turn triggers the alarm), and this event is initially enabled to express that the fire alarm is ready. Can one assume weak fairness of this sensor event? <div class="plugin_wrap"><p><a class="folder" href="#folded_e9e858e6bea9d29507a950f7ecc554e3_1">Check your answer </a></p><div class="folded hidden" id="folded_e9e858e6bea9d29507a950f7ecc554e3_1">
<p>
If one assumes weak fairness for this event then the property “eventually alarm” will hold, which is probably wrong as one would likely want to allow a scenario with fire (and so alarm) never happening. Hence assuming weak fairness, in this case, seems unreasonable.
</p>
</div></div></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> A coffee machine responds to the user pressing a button by making a cup of coffee. Is it reasonable to assume weak fairness for the button pressing event? <div class="plugin_wrap"><p><a class="folder" href="#folded_e9e858e6bea9d29507a950f7ecc554e3_2">Check your answer </a></p><div class="folded hidden" id="folded_e9e858e6bea9d29507a950f7ecc554e3_2">
<p>
It would be difficult to guarantee much about the human user, so such an assumption is likely unreasonable.
</p>
</div></div></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> An asynchronous hardware module <code>M</code> responds to input <code><span style='color:red; '>i</span></code> by computing output <code><span style='color:blue; '>o</span></code>. Part of the computation is delegated to another asynchronous module <code>M′</code> as follows: <code>M</code> sends a request <code><span style='color:blue; '>req</span></code> (that is an output of <code>M</code> and an input of <code>M′</code>) and waits for an acknowledgement <code><span style='color:red; '>ack</span></code> (that is an output of <code>M′</code> and an input of <code>M</code>), after which output <code>o</code> is produced. Is it reasonable to assume weak fairness of <code><span style='color:red; '>ack</span></code> when verifying <code>M</code>? <div class="plugin_wrap"><p><a class="folder" href="#folded_e9e858e6bea9d29507a950f7ecc554e3_3">Check your answer </a></p><div class="folded hidden" id="folded_e9e858e6bea9d29507a950f7ecc554e3_3">
<p>
As <code><span style='color:red; '>ack</span></code> is an input of <code>M</code>, it has to be carefully considered. Note also that <code><span style='color:blue; '>o</span></code> causally depends on <code><span style='color:red; '>ack</span></code>, so it may be impossible to prove that <code><span style='color:blue; '>o</span></code> is eventually produced without assuming weak fairness of <code><span style='color:red; '>ack</span></code>. If <code>M′</code> is unknown at the design time, it would be unreasonable to make this assumption – there is no guaranee that <code>M′</code> will ever produce <code><span style='color:red; '>ack</span></code>. However, if <code>M′</code> is well understood or designed in-house, one can formally verify that <code>M′</code> acknowledges every request, and then confidently assume weak fairness of <code><span style='color:red; '>ack</span></code> when verifying <code>M</code>.
</p>
</div></div></div>
</li>
</ul>

</div>

<h3 id="strong_fairness">Strong fairness</h3>
<div class="level3">

<p>
In constrast to weak fairness that is concerned with fair scheduling of <em class="u">concurrent</em> events, strong fairness is concerned with fair selection of options of a <em class="u">choice</em>. Recall the MUTEX example considered above,
<img src="mutex.stg.svg" width="182" height="115" class="svgscaleinsert mediacenter" alt="Mutex STG">
with the liveness property
</p>
<div class="wrap_code plugin_wrap">
<p>
always, if <code><span style='color:red; '>r1</span></code> then <code><span style='color:red; '>r1</span></code> strong_until <code><span style='color:red; '>r1</span></code> &amp; <code><span style='color:blue; '>g1</span></code>
</p>
</div>
<p>
This property is violated on the following  trace:
<img src="lasso-shaped-trace.svg" width="232" height="86" class="svgscaleinsert mediacenter" alt="Lasso-shaped violation trace">
</p>

<p>
Note that this trace enables <code><span style='color:blue; '>g1+</span></code> infinitely many times, but never fires it – the other option of the choice, <code><span style='color:blue; '>g2+</span></code>, is always selected instead, and so <code><span style='color:blue; '>g1+</span></code> is indefinitely pre-empted.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap" style="width: 80%;">
<p>
From physical considerations, one can argue that this violation trace is not possible in reality and should be ruled out during formal verification. Indeed, if <code><span style='color:red; '>r1+</span></code> has fired before <code><span style='color:red; '>r2-</span></code> then waiting <code><span style='color:red; '>r1</span></code> will necessarily win next time, as it will have a sufficiently long window of opportunity (after <code><span style='color:red; '>r2-</span></code>, the MUTEX will execute <code><span style='color:blue; '>g2-</span></code> and then wait for <code><span style='color:red; '>r2+</span></code>, with the latter incurring at least one inverter&#039;s delay). In other words, it is reasonable to assume strong fairness for MUTEX&#039;s grants (unless the internal implementation of MUTEX is very biased/poor).
</p>
</div>
<p>
Fortunately, it is possible to exclude such unfair traces from consideration by passing some extra knowledge that a particular choice option (in this case, <code><span style='color:red; '>r1+</span></code>) cannot be pre-empted indefinitely as an assumption encoded as a part of the property. The assumption that a certain transition <code>T</code>, that is an option of a choice, is selected fairly is common, and there is a standard ‘incantation’ for expressing it as a temporal property defined as 
</p>
<div class="wrap_code plugin_wrap">
<p>
strongly_fair(<code>T</code>) := if always, eventually <code>T</code> is enabled then always, eventually <code>T</code> fires
</p>
</div>
<p>
Intuitively, this states that if <code>T</code> is enabled infinitely many times then it fires infinitely many times. Note that:
</p>
<ul>
<li class="level1"><div class="li"> One has to track somehow whether <code>T</code> has fired. In circuits and STGs this is usually not a problem as firing a signal transition changes the value of a signal, e.g. strong fairness of <code><span style='color:blue; '>g1+</span></code> in our example can be expressed as, “if always, eventually <code><span style='color:blue; '>g1+</span></code> is enabled then always, eventually <code><span style='color:blue; '>g1</span></code>”.</div>
</li>
<li class="level1"><div class="li"> The formula refers to the enabledness of a transition – it may be difficult to express this in some cases, e.g. if atomic propositions correspond to the values of signals. In circuits, one can use the function computed by the gate or latch, and in STGs one can create additional atomic propositions to represent whether a place holds a token, or even directly for the enabledness status of a transition.</div>
</li>
</ul>

<p>
Now, one can use the formula “strongly_fair(<code>T</code>)” as an assumption under which another property is checked, i.e. by putting this assumption on the left hand side of an implication, and the property on its right hand side. For example, the property discussed above can be reformulated as
</p>
<div class="wrap_code plugin_wrap">
<p>
if strongly_fair(<code><span style='color:blue; '>g1+</span></code>) then<br/>

  always, if <code><span style='color:red; '>r1</span></code> then <code><span style='color:red; '>r1</span></code> strong_until <code><span style='color:red; '>r1</span></code> &amp; <code><span style='color:blue; '>g1</span></code>
</p>
</div>
</div>

<h4 id="exercise">Exercise</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> Suppose a vending machine dispenses an apple or a banana in response to the user pressing one of two buttons. Is it reasonable to assume strong fairness for the event of pressing the banana button? <div class="plugin_wrap"><p><a class="folder" href="#folded_e9e858e6bea9d29507a950f7ecc554e3_4">Check your answer </a></p><div class="folded hidden" id="folded_e9e858e6bea9d29507a950f7ecc554e3_4">
<p>
This would allow one to prove the property that “if the users keep coming, the machine will keep dispensing bananas”, which is probably difficult to guarantee in reality, e.g. it may happen that none of the users likes bananas, or bananas are overpriced. So this assumption is probably unwarranted.
</p>
</div></div></div>
</li>
</ul>

</div>

<h2 id="syntactic_vs_semantic_aborts">Syntactic vs. Semantic aborts</h2>
<div class="level2">

<p>
Electronic circuits often have ‘disruptive’ operations like resets, aborts, interrupts, etc. However, temporal properties are often specified for the ‘normal’ mode of operation, and are not meant to hold during and across such disruptions. For example, the property
</p>
<div class="wrap_code plugin_wrap">
<p>
if weakly_fair(<code><span style='color:blue; '>ack+</span></code>) then<br/>

  always, if <code><span style='color:red; '>req</span></code> then <code><span style='color:red; '>req</span></code> strong_until <code><span style='color:red; '>req</span></code> &amp; <code><span style='color:blue; '>ack</span></code>
</p>
</div>
<p>
becomes violated if a reset occurs after the request but before the acknowledgement.
</p>

<p>
Some properties, in particular invariants, are easy to re-write by taking disruptions into account – e.g. one can simply replace an invariant <code>always COND</code> by the invariant <code>always, rst or COND</code>, where <code>rst</code> is the reset signal. However, for more complicated temporal properties such re-writing often results in cumbersome formulae and is error-prone. Hence, special operators are used to handle disruptions, e.g. ‘abort’ in PSL, and ‘accept_on’ and ‘reject_on’ in SVA. For example, for a temporal property <code>P</code>, one can write <code>P abort rst</code> in PSL or <code>accept_on(rst) P</code> in SVA, to express that if <code>rst</code> is asserted during the execution and <code>P</code> has “not failed yet” then the overall property is considered to hold on this execution. For example, one can rewrite the above property as
</p>
<div class="wrap_code plugin_wrap">
<p>
if weakly_fair(<code><span style='color:blue; '>ack+</span></code>) then<br/>

  always,<br/>

    if <code><span style='color:red; '>req</span></code> then <code><span style='color:red; '>req</span></code> strong_until <code><span style='color:red; '>req</span></code> &amp; <code><span style='color:blue; '>ack</span></code><br/>

    abort rst
</p>
</div>
<p>
The definition of the ‘abort’ operator in PSL has changed from version 1.01 to version
1.1 of the standard: ‘Semantic’ aborts turned into ‘syntactic’ aborts, following the terminology of <a href="#refnotes:1:note3" name="refnotes:1:ref4" class="refnotes-ref note-popup">[3]</a>. The difference is about at which point of time a temporal property <code>P</code> is considered to have failed and so no longer can be ‘rescued’ by an arrival of <code>rst</code>. For example, the property <code>next false</code> semantically fails <em class="u">before</em> the first tick of global time, and so is equal to <code>false</code> and cannot be rescued, i.e.
</p>
<div class="wrap_code plugin_wrap">
<p>
(next false) semantic_abort rst = false semantic_abort rst = false
</p>
</div>
<p>
In contrast, <code>next false</code> syntactically fails <em class="u">after</em> the first tick of global time, and so can be rescued, i.e.
</p>
<div class="wrap_code plugin_wrap">
<p>
(next false) syntactic_abort rst ≠ false syntactic_abort rst
</p>
</div>
<p>
Another example from <a href="#refnotes:1:note3" name="refnotes:1:ref5" class="refnotes-ref note-popup">[3]</a> is the property
</p>
<div class="wrap_code plugin_wrap">
<p>
(always !p) &amp; (eventually p)
</p>
</div>
<p>
that is a logic contradiction and so fails semantically before the first tick of global time; however, it never fails syntactically (as long as <code>!p</code> holds), as one can always keep waiting for the eventuality.
</p>

<p>
Hence, syntactic aborts have some rather pathological and counterintuitive behaviour, in particular, equivalent properties (i.e. those holding on the same infinite executions) may cease to be equivalent in the context of a syntactic abort. This has implications for formulae simplification – e.g. simplifying <code>next false</code> to <code>false</code> is no longer possible as it may occur as a sub-formula in a property with a syntactic abort.
</p>

<p>
Unfortunately, while semantic aborts do not have such pathologies, they are computationally much more expensive, especially if nested <a href="#refnotes:1:note3" name="refnotes:1:ref6" class="refnotes-ref note-popup">[3]</a>, which motivated the change of the PSL standard. Nevertheless, <span class="wrap_todo ">Workcraft uses “good old” semantical aborts.</span>
</p>

</div>

<h2 id="temporal_modalities_referring_to_the_past">Temporal modalities referring to the past</h2>
<div class="level2">

<p>
Workcraft does not currently support any temporal modalities referring to the past. However, there is a general result <a href="#refnotes:1:note4" name="refnotes:1:ref7" class="refnotes-ref note-popup">[4]</a> that properties with such modalities do not add any expressive power, i.e. references to the bounded past (i.e. when there is a starting point and no time prior to that) can always be eliminated. This may be computationally expensive and lead to a blow up in the size of the property; however, in practical properties, references to the past are usually used in a very restricted context and can be easily eliminated.
</p>

<p>
For example, consider the property, “always, if <code><span style='color:blue; '>ack</span></code> then previously <code><span style='color:red; '>req</span></code>”. A violation trace for this property would have a (perhaps empty) prefix where <code><span style='color:red; '>req</span></code> is false, followed by a state where <code><span style='color:blue; '>ack</span></code> is true, followed by any infinite continuation. (At this point one should realise that the violation can be demonstrated by a finite trace, i.e. this is a safety property, but not an invariant, which is rather unusual – one may start suspecting that there is something wrong with the formulation, see the discussion below.) So one can capture the negation of this property as “!<code><span style='color:red; '>req</span></code> strong_until <code><span style='color:blue; '>ack</span></code>”, and so the property itself is equivalent to “!(!<code><span style='color:red; '>req</span></code> strong_until <code><span style='color:blue; '>ack</span></code>)”, which does not refer to the past. This can be simplified by removing the double negation to “!<code><span style='color:blue; '>ack</span></code> weak_until <code><span style='color:red; '>req</span></code> &amp; !<code><span style='color:blue; '>ack</span></code>”.
</p>
<div class="wrap_center wrap_round wrap_important plugin_wrap" style="width: 80%;">
<p>
Note that this property is (probably) not what one had intended to express, as it allows:
</p>
<ul>
<li class="level1"><div class="li"> the request to withdraw prematurely, e.g. the property holds on the trace <code><span style='color:red; '>req</span>&amp;!<span style='color:blue; '>ack</span> !<span style='color:red; '>req</span>&amp;!<span style='color:blue; '>ack</span> !<span style='color:red; '>req</span>&amp;<span style='color:blue; '>ack</span> …</code>; and</div>
</li>
<li class="level1"><div class="li"> multiple acknowledgements for the same request, e.g. the property holds on the trace <code><span style='color:red; '>req</span>&amp;!<span style='color:blue; '>ack</span> <span style='color:red; '>req</span>&amp;<span style='color:blue; '>ack</span> !<span style='color:red; '>req</span>&amp;<span style='color:blue; '>ack</span> !<span style='color:red; '>req</span>&amp;!<span style='color:blue; '>ack</span> !<span style='color:red; '>req</span>&amp;<span style='color:blue; '>ack</span> !<span style='color:red; '>req</span>&amp;!<span style='color:blue; '>ack</span> !<span style='color:red; '>req</span>&amp;<span style='color:blue; '>ack</span> …</code>, which makes the property rather easy to satisfy – it effectively just states that the first request occurs before the first acknowledgement, ignoring all the subsequent occurrences.</div>
</li>
</ul>

<p>
Hence one would probably want to modify the property to fix the above problems, which makes expressing it as a temporal property non-trivial. Moreover, using temporal verification is an overkill in this case – one can see that the fixed property is an invariant and so can be expressed in REACH – this is how Workcraft&#039;s <a href="../handshake_verification/start.html" class="wikilink1" title="tutorial:method:handshake_verification:start" data-wiki-id="tutorial:method:handshake_verification:start">Hanshake Wizard</a> verifies handshakes.
</p>
</div><div class="wrap_center wrap_round wrap_tip plugin_wrap" style="width: 80%;">
<p>
Before trying to express a property as a temporal formula, think whether its violation can be seen on a finite trace. If so, this is a safety property, and sensible practical safety properties are usually invariants and so you are likely to be better off using REACH. Furthermore, this thinking process would help you understand your property better.
</p>

<p>
For example, for the above property, chances are that you are trying to capture the requirement that transitions of <code><span style='color:red; '>req</span></code> and <code><span style='color:blue; '>ack</span></code> follow the sequence <code>… <span style='color:red; '>req+</span> … <span style='color:blue; '>ack+</span> … <span style='color:red; '>req-</span> … <span style='color:blue; '>ack-</span> …</code> (where <code>…</code> does not have any occurrences of <code><span style='color:red; '>req</span></code> and <code><span style='color:blue; '>ack</span></code>), and this can be captured as the following reachability-like property:
</p>
<ul>
<li class="level1"><div class="li"> <code>!<span style='color:red; '>req</span> &amp; !<span style='color:blue; '>ack</span></code>:   <code><span style='color:red; '>req-</span>, <span style='color:blue; '>ack+</span>, <span style='color:blue; '>ack-</span></code> must be disabled;</div>
</li>
<li class="level1"><div class="li"> <code> <span style='color:red; '>req</span> &amp; !<span style='color:blue; '>ack</span></code>:   <code><span style='color:red; '>req+</span>, <span style='color:red; '>req-</span>, <span style='color:blue; '>ack-</span></code> must be disabled;</div>
</li>
<li class="level1"><div class="li"> <code> <span style='color:red; '>req</span> &amp;  <span style='color:blue; '>ack</span></code>:   <code><span style='color:red; '>req+</span>, <span style='color:blue; '>ack+</span>, <span style='color:blue; '>ack-</span></code> must be disabled;</div>
</li>
<li class="level1"><div class="li"> <code>!<span style='color:red; '>req</span> &amp;  <span style='color:blue; '>ack</span></code>:   <code><span style='color:red; '>req+</span>, <span style='color:red; '>req-</span>, <span style='color:blue; '>ack+</span></code> must be disabled.</div>
</li>
</ul>

<p>
This can be easily captured in REACH. The <a href="../handshake_verification/start.html" class="wikilink1" title="tutorial:method:handshake_verification:start" data-wiki-id="tutorial:method:handshake_verification:start">Hanshake Wizard</a> tutorial lists some other properties which should be verified for handshakes, in particular the receptiveness conditions.
</p>
</div>
</div>

<h2 id="solutions">Solutions</h2>
<div class="level2">

<p>
Download all the Workcraft models discussed in this tutorial here: <span class="wrap_download "><a href="temporal_verification.zip" class="media mediafile mf_zip" title="tutorial:method:temporal_verification:temporal_verification.zip (11.2 KB)">Temporal Verification Models</a> (11 KiB)</span>
</p>

</div>
<div class="level1">
<div class="plugin_include_content plugin_include__tutorial:feedback" id="plugin_include__tutorial__feedback">
<div class="wrap_hide plugin_wrap"><pre class="code">===== Feedback =====</pre>
<form class="bureaucracy__plugin" id="bureaucracy__plugin1" enctype="multipart/form-data" method="post" action="start.html" accept-charset="utf-8"><div class="no">
<input type="hidden" name="sectok" value="76e97b919f59bf5330d969a72ba5bf17" /><input type="hidden" name="id" value="tutorial:method:temporal_verification:start" /><input type="hidden" name="bureaucracy[$$id]" value="1" /><fieldset ><legend>Comments or suggestions for improving this tutorial</legend>
<label><span>Name (optional)</span> <input type="text" name="bureaucracy[1]" class="edit" /></label>
<label><span>Email (optional)</span> <input type="text" name="bureaucracy[2]" class="edit" /></label>
<label class=" textareafield">
    <span>Feedback <sup>*</sup></span>
    <textarea name="bureaucracy[3]" id="" rows="10" cols="10" class="edit required&quot; required=&quot;required"></textarea>
</label><button type="submit">Submit</button>
</fieldset>
</div></form>
</div><div class="wrap_hide plugin_wrap"><ul>
<li class="level1"><div class="li"> As discussed in <a href="https://www.dokuwiki.org/plugin:include#controlling_header_size_in_included_pages" class="urlextern" title="https://www.dokuwiki.org/plugin:include#controlling_header_size_in_included_pages" rel="ugc nofollow">https://www.dokuwiki.org/plugin:include#controlling_header_size_in_included_pages</a>, by default, the headers in included pages start one level lower than the last header in the current page. This can be tweaked by adding an empty header above the include:\\<pre class="code">====== ======
{{page&gt;:tutorial:feedback&amp;inline}}</pre>
</div>
</li>
<li class="level1"><div class="li"> For offline help generation the content of <code>feedback</code> page should be temporary wrapped in <code>&lt;WRAP hide&gt;</code>. Note that the headers still propagate to the table of contents even if inside the hidden wrap. Therefore the <strong>Feedback</strong> title needs to be converted to something else, e.g. to code by adding two spaces in front.</div>
</li>
</ul>
</div></div>

</div>

<h2 id="references">References</h2>
<div class="level2">









</div>
<div class="refnotes">
<hr>
<div class="notes">
<div class="note left">
<b><a name="refnotes:1:note1" class="nolink">[1]</a></b>
<span id="refnotes:1:note1:text">
Leslie Lamport: <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/What-Good-Is-Temporal-Logic.pdf" class="urlextern" title="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/What-Good-Is-Temporal-Logic.pdf" rel="ugc nofollow">What Good is Temporal Logic?</a> Proc. IFIP Congress, Information Processing vol. 83, R. E. A. Mason (Ed.), Elsevier Publishers (1983) 657-668.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note2" class="nolink">[2]</a></b>
<span id="refnotes:1:note2:text">
Dimitrie O. Paun and Marsha Chechik: <a href="https://arxiv.org/pdf/cs/9906031" class="urlextern" title="https://arxiv.org/pdf/cs/9906031" rel="ugc nofollow">Events in linear-time properties.</a> Proc. IEEE International Symposium on Requirements Engineering (1999) 123-132.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note3" class="nolink">[3]</a></b>
<span id="refnotes:1:note3:text">
Roy Armoni, Doron Bustan, Orna Kupferman, Moshe Y. Vardi: <a href="https://www.cse.huji.ac.il/~ornak/publications/tacas03b.pdf" class="urlextern" title="https://www.cse.huji.ac.il/~ornak/publications/tacas03b.pdf" rel="ugc nofollow">Aborts vs Resets in Linear Temporal Logic.</a> Proc. 9th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS), Springer-Verlag (2003) 65-80.
</span></div>
<div class="note left">
<b><a name="refnotes:1:note4" class="nolink">[4]</a></b>
<span id="refnotes:1:note4:text">
Christian Dax, Felix Klaedtke, and Martin Lange: <a href="https://doi.org/10.1007/s00236-010-0118-3" class="urlextern" title="https://doi.org/10.1007/s00236-010-0118-3" rel="ugc nofollow">On Regular Temporal Logics with Past</a>. Acta Informatica, vol. 47, Springer Verlag (2010) 251–277.
</span></div>
</div>
</div>
<div class="footnotes">
<div class="fn"><sup><a href="#fnt__1" id="fn__1" class="fn_bot">1)</a></sup> 
<div class="content">In any SI property, the occurrences of ‘next’ can be removed by clever use of ‘until’, but the resulting formulation usually becomes much less intuitive.</div></div>
</div>

                    <!-- wikipage stop -->
                                    </div>
<!--
                <div class="docInfo">
                    workcraft @ <bdi>tutorial/method/temporal_verification/start.txt</bdi> · Modified 2020/09/24 15:38 by <bdi>victor</bdi>                </div>
-->
                            </div></div><!-- /content -->

            <hr class="a11y" />

            <!-- PAGE ACTIONS -->
<!--
            <div id="dokuwiki__pagetools">
                            <h3 class="a11y">Page Tools</h3>
                <div class="tools">
                    <ul>
                        <li class="edit"><a href="start.html" title="Edit this page [e]" rel="nofollow" accesskey="e"><span>Edit this page</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg></a></li><li class="revs"><a href="start.html" title="Old revisions [o]" rel="nofollow" accesskey="o"><span>Old revisions</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M11 7v5.11l4.71 2.79.79-1.28-4-2.37V7m0-5C8.97 2 5.91 3.92 4.27 6.77L2 4.5V11h6.5L5.75 8.25C6.96 5.73 9.5 4 12.5 4a7.5 7.5 0 0 1 7.5 7.5 7.5 7.5 0 0 1-7.5 7.5c-3.27 0-6.03-2.09-7.06-5h-2.1c1.1 4.03 4.77 7 9.16 7 5.24 0 9.5-4.25 9.5-9.5A9.5 9.5 0 0 0 12.5 2z"/></svg></a></li><li class="backlink"><a href="start.html" title="Backlinks" rel="nofollow"><span>Backlinks</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M10.59 13.41c.41.39.41 1.03 0 1.42-.39.39-1.03.39-1.42 0a5.003 5.003 0 0 1 0-7.07l3.54-3.54a5.003 5.003 0 0 1 7.07 0 5.003 5.003 0 0 1 0 7.07l-1.49 1.49c.01-.82-.12-1.64-.4-2.42l.47-.48a2.982 2.982 0 0 0 0-4.24 2.982 2.982 0 0 0-4.24 0l-3.53 3.53a2.982 2.982 0 0 0 0 4.24m2.82-4.24c.39-.39 1.03-.39 1.42 0a5.003 5.003 0 0 1 0 7.07l-3.54 3.54a5.003 5.003 0 0 1-7.07 0 5.003 5.003 0 0 1 0-7.07l1.49-1.49c-.01.82.12 1.64.4 2.43l-.47.47a2.982 2.982 0 0 0 0 4.24 2.982 2.982 0 0 0 4.24 0l3.53-3.53a2.982 2.982 0 0 0 0-4.24.973.973 0 0 1 0-1.42z"/></svg></a></li><li class="export_pdf"><a href="start.html" title="Export to PDF" rel="nofollow"><span>Export to PDF</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M14 9h5.5L14 3.5V9M7 2h8l6 6v12a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2m4.93 10.44c.41.9.93 1.64 1.53 2.15l.41.32c-.87.16-2.07.44-3.34.93l-.11.04.5-1.04c.45-.87.78-1.66 1.01-2.4m6.48 3.81c.18-.18.27-.41.28-.66.03-.2-.02-.39-.12-.55-.29-.47-1.04-.69-2.28-.69l-1.29.07-.87-.58c-.63-.52-1.2-1.43-1.6-2.56l.04-.14c.33-1.33.64-2.94-.02-3.6a.853.853 0 0 0-.61-.24h-.24c-.37 0-.7.39-.79.77-.37 1.33-.15 2.06.22 3.27v.01c-.25.88-.57 1.9-1.08 2.93l-.96 1.8-.89.49c-1.2.75-1.77 1.59-1.88 2.12-.04.19-.02.36.05.54l.03.05.48.31.44.11c.81 0 1.73-.95 2.97-3.07l.18-.07c1.03-.33 2.31-.56 4.03-.75 1.03.51 2.24.74 3 .74.44 0 .74-.11.91-.3m-.41-.71l.09.11c-.01.1-.04.11-.09.13h-.04l-.19.02c-.46 0-1.17-.19-1.9-.51.09-.1.13-.1.23-.1 1.4 0 1.8.25 1.9.35M8.83 17c-.65 1.19-1.24 1.85-1.69 2 .05-.38.5-1.04 1.21-1.69l.48-.31m3.02-6.91c-.23-.9-.24-1.63-.07-2.05l.07-.12.15.05c.17.24.19.56.09 1.1l-.03.16-.16.82-.05.04z"/></svg></a></li><li class="menuitemfolded"><a href="javascript:void(0);" title="Fold/unfold all" rel="nofollow" class="fold_unfold_all_new" onclick="fold_unfold_all();"><span>Fold/unfold all</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M 2,0 L 6.5,3 L 2,6 z M 8,6.6 L 12.5,9.6 L 8,12.6 z M 14,13.2 L 20,13.2 L 17,17.7 z"/></svg></a></li><li class="menuitem"><a href="start.html" title="Rename Page" rel="nofollow" class=" plugin_move_page "><span>Rename Page</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M18,4V3A1,1 0 0,0 17,2H5A1,1 0 0,0 4,3V7A1,1 0 0,0 5,8H17A1,1 0 0,0 18,7V6H19V10H9V21A1,1 0 0,0 10,22H12A1,1 0 0,0 13,21V12H21V4H18Z" /></svg></a></li><li class="siteexport_addpage"><a href="start.html" title="Export Page to HTML/PDF" rel="nofollow"><span>Export Page to HTML/PDF</span><svg width="61px" height="51px" viewBox="0 0 61 51" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs></defs><path d="M26.1891503,39.0065635 L26.0876578,38.9773206 L60.6523866,1.23972885 L60.4321374,2.11844376 L60.476442,2.07071678 L60.4265202,2.14085429 L49.5024876,45.7237994 L32.8255882,40.9187101 L26,50.508302 L26,39.2103249 L26.1891503,39.0065635 Z M60.9727675,0.862917243 L22.2676619,38.2155059 L-0.00245042233,30.2214566 L60.9727675,0.862917243 Z" id="Paper-Plane"></path></svg></a></li><li class="top"><a href="#dokuwiki__top" title="Back to top [t]" rel="nofollow" accesskey="t"><span>Back to top</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"/></svg></a></li>                    </ul>
                </div>
                        </div>
-->
        </div><!-- /wrapper -->

        
<!-- ********** FOOTER ********** -->
<!--
<div id="dokuwiki__footer"><div class="pad">
    
    <div class="buttons">
                <a href="https://www.dokuwiki.org/donate" title="Donate" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-donate.gif" width="80" height="15" alt="Donate" /></a>
        <a href="https://php.net" title="Powered by PHP" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-php.gif" width="80" height="15" alt="Powered by PHP" /></a>
        <a href="../../check/referer" title="Valid HTML5" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-html5.png" width="80" height="15" alt="Valid HTML5" /></a>
        <a href="../../css-validator/check/referer.fe4c581d16fb9f59f07485ddb441e467" title="Valid CSS" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-css.png" width="80" height="15" alt="Valid CSS" /></a>
        <a href="https://dokuwiki.org/" title="Driven by DokuWiki" ><img
            src="../../lib/tpl/dokuwiki-light-export/images/button-dw.png" width="80" height="15"
            alt="Driven by DokuWiki" /></a>
    </div>
</div></div>
-->
    </div></div><!-- /site -->

    <div class="no"><img src="../../lib/exe/taskrunner.324dac580c6f8e151eaead5d0aabbc78.gif" width="2" height="1" alt="" /></div>
    <div id="screen__mode" class="no"></div></body>
</html>
